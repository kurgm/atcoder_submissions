#!/usr/bin/env python3
import heapq
import sys
from typing import List


class PQ:
    def __init__(self, q: "list[int]"):
        self._pq = q[:]
        heapq.heapify(self._pq)
        self._pqset = set(self._pq)

    def peek(self) -> int:
        return self._pq[0]

    def push(self, val: int) -> None:
        heapq.heappush(self._pq, val)
        self._pqset.add(val)

    def pop(self) -> int:
        popped = heapq.heappop(self._pq)
        while popped not in self._pqset:
            popped = heapq.heappop(self._pq)
        self._pqset.remove(popped)
        return popped

    def remove(self, val: int) -> None:
        self._pqset.remove(val)

    def has(self, val: int) -> bool:
        return val in self._pqset

    def pushpop(self, val: int) -> int:
        self._pqset.add(val)
        popped = heapq.heappushpop(self._pq, val)
        while popped not in self._pqset:
            popped = heapq.heappop(self._pq)
        self._pqset.remove(popped)
        return popped

    def size(self) -> int:
        return len(self._pqset)


def solve(N: int, M: int, K: int, A: "List[int]"):
    Rmap = {
        i: Rj
        for Rj, (_, i) in enumerate(sorted((-Ai, i) for i, Ai in enumerate(A)))
    }
    R_Ai = {Rj: A[i] for i, Rj in Rmap.items()}
    R = [Rmap[i] for i in range(N)]
    del Rmap

    items = R[:M]
    items.sort()
    bigger = PQ([-Rj for Rj in items[:-K]])
    smaller = PQ(items[-K:])
    s = sum(R_Ai[Rj] for Rj in items[-K:])
    yield s
    for Rj, Rk in zip(R[M:], R):
        done = False
        if smaller.has(Rk):
            smaller.remove(Rk)
            s -= R_Ai[Rk]
            if bigger.size():
                pushed = -bigger.pop()
            else:
                pushed = Rj
                done = True
            smaller.push(pushed)
            s += R_Ai[pushed]
        else:
            bigger.remove(-Rk)

        if not done:
            pushed = Rj
            popped = smaller.pushpop(pushed)
            s += R_Ai[pushed] - R_Ai[popped]
            bigger.push(-popped)
        yield s


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    A = [int(next(tokens)) for _ in range(N)]  # type: "List[int]"
    print(*solve(N, M, K, A))


if __name__ == '__main__':
    main()
